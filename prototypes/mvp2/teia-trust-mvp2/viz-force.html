<!DOCTYPE html>
<html>
<head>
    <title>Teia Trust Graph MVP2 (Force-Graph)</title>
    <script src="https://unpkg.com/d3"></script>
    <script src="https://unpkg.com/force-graph"></script>
    <style>
        body { background: #0f172a; color: #f8fafc; font-family: monospace; margin: 0; overflow: hidden; }
        #controls { height: 60px; padding: 10px 20px; background: #1e293b; border-bottom: 1px solid #334155; display: flex; gap: 10px; align-items: center; }
        #legend { position: absolute; bottom: 20px; left: 20px; background: rgba(15, 23, 42, 0.9); padding: 15px; border-radius: 8px; border: 1px solid #334155; z-index: 5; font-size: 0.8em; line-height: 1.6em; }
        #graph-container { width: 100vw; height: calc(100vh - 80px); background: #0f172a; position: relative; min-height: 400px; }
        input { background: #334155; border: 1px solid #475569; color: white; padding: 10px; min-width: 350px; border-radius: 4px; }
        button { background: #2563eb; color: white; border: none; padding: 10px 20px; cursor: pointer; border-radius: 4px; font-weight: bold;}
        button:hover { background: #1d4ed8; }
        .legend-item { display: flex; align-items: center; gap: 8px; }
        .dot { width: 10px; height: 10px; border-radius: 50%; }
        .community-photography { background: #38bdf8; }
        .community-glitch { background: #f43f5e; }
        .community-3d { background: #8b5cf6; }
        .community-illustration { background: #fb923c; }
        .community-pfp { background: #2dd4bf; }
        
        /* Modal Styles */
        #modal { display: none; position: fixed; z-index: 10; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); }
        .modal-content { background: #1e293b; margin: 15% auto; padding: 20px; border: 1px solid #334155; width: 400px; border-radius: 8px; position: relative; }
        .modal-header { font-size: 1.2em; font-weight: bold; margin-bottom: 15px; border-bottom: 1px solid #334155; padding-bottom: 10px; }
        .modal-body div { margin-bottom: 15px; }
        .modal-body label { color: #94a3b8; display: block; font-size: 0.8em; margin-bottom: 4px; }
        .close { position: absolute; right: 20px; top: 15px; cursor: pointer; color: #94a3b8; }
        .btn-copy { background: #475569; font-size: 0.7em; margin-left: 5px; padding: 4px 8px; color: white; border: none; border-radius: 3px; cursor: pointer; }
    </style>
</head>
<body>

<div id="controls">
    <label>Center:</label>
    <input type="text" id="centerNode" placeholder="tz... or id" value="">
    <button onclick="drawGraph()">Visualize Trust</button>
    <label style="margin-left:12px; color:#94a3b8">Tag:</label>
    <input id="filterTag" placeholder="e.g. photography" style="width:150px; background:#24303f; color:#e6eef8; border:1px solid #334155; padding:6px; border-radius:4px;" />
    <label style="margin-left:8px; color:#94a3b8">Top N:</label>
    <input id="maxFirst" type="number" min="5" max="200" value="80" style="width:70px; background:#24303f; color:#e6eef8; border:1px solid #334155; padding:6px; border-radius:4px;" />
    <label style="margin-left:8px; color:#94a3b8"><input id="showSecond" type="checkbox" checked /> show 2nd-degree</label>
    <button id="btnRadial" onclick="toggleRadial()" title="Toggle radial layout (experimental)">Radial: off</button>
    <button id="btnRings" onclick="toggleRings()" title="Toggle guide rings">Rings: off</button>
    <button id="btnCluster" onclick="toggleClusterLayout()" title="Toggle community clustering">Cluster: off</button>
</div>

<div id="graph-container"></div>

<div id="legend">
    <div class="legend-item"><div class="dot community-photography"></div> <span>Photography</span></div>
    <div class="legend-item"><div class="dot community-glitch"></div> <span>Glitch Art</span></div>
    <div class="legend-item"><div class="dot community-3d"></div> <span>3D / Generative</span></div>
    <div class="legend-item"><div class="dot community-illustration"></div> <span>Illustration</span></div>
    <div class="legend-item"><div class="dot community-pfp"></div> <span>PFP / Collectibles</span></div>
    <div style="margin-top:8px; color: #94a3b8; font-size: 0.9em; border-top: 1px solid #334155; padding-top: 8px;">
        <span style="color:#22c55e">ðŸŸ¢ Green Outer Ring:</span> Directly Trusted<br>
        <span style="color:#ffffff">â­• White Center:</span> High Reputation<br>
        <span style="color:rgba(56,189,248,0.6)">â”€â”€</span> Direct edges &nbsp; <span style="color:rgba(234,179,8,0.6)">â”€â”€</span> 2nd-degree discovery<br>
        <b>Hover node to focus paths â€” use Tag / Top N to filter</b>
    </div>
</div>

<div id="modal">
    <div class="modal-content">
        <span class="close" onclick="closeModal()">&times;</span>
        <div class="modal-header">Profile Info</div>
        <div class="modal-body" id="modalBody"></div>
    </div>
</div>

<script>
    let graph;
    let hoverNode = null;
    const neighbors = new Set();
    const neighborLinks = new Set();
    const neighborsLimited = new Set();
    const neighborLinksLimited = new Set();
    let simulationSettled = false; // true when layout has cooled but interactions remain active

    function closeModal() { document.getElementById('modal').style.display = 'none'; }
    function copyText(text) {
        navigator.clipboard.writeText(text).then(() => {
            const btn = event.target;
            const originalText = btn.innerText;
            btn.innerText = "Copied!";
            setTimeout(() => btn.innerText = originalText, 1000);
        });
    }

    // --- Layout and Hover helpers ---
    let clusterEnabled = false;
    let communityCenters = {}; 
    const MAX_NEIGHBOR_LABELS = 40; 
    let lastHoverNodeId = null;

    function handleHover(node) {
        if (node && String(node.id) === lastHoverNodeId) return; // skip redundant
        
        neighbors.clear(); neighborLinks.clear(); neighborsLimited.clear(); neighborLinksLimited.clear();
        if (node) {
            hoverNode = node;
            lastHoverNodeId = String(node.id);
            const gData = graph.graphData();
            
            gData.links.forEach(link => {
                const s = typeof link.source === 'object' ? String(link.source.id) : String(link.source);
                const t = typeof link.target === 'object' ? String(link.target.id) : String(link.target);
                if (s === node.id || t === node.id) {
                    neighborLinks.add(link);
                    neighbors.add(s); neighbors.add(t);
                }
            });
            const neighborIds = Array.from(neighbors).slice(0, MAX_NEIGHBOR_LABELS);
            neighborIds.forEach(id => neighborsLimited.add(id));
            gData.links.forEach(l => {
                const s = typeof l.source === 'object' ? String(l.source.id) : String(l.source);
                const t = typeof l.target === 'object' ? String(l.target.id) : String(l.target);
                if (neighborsLimited.has(s) && neighborsLimited.has(t)) neighborLinksLimited.add(l);
            });
        } else {
            hoverNode = null;
            lastHoverNodeId = null;
        }

        // Force a robust canvas refresh
        if (graph) {
            // Use d3AlphaTarget if available, or fallback to refresh/tick methods
            if (typeof graph.d3AlphaTarget === 'function') {
                graph.d3AlphaTarget(0.0001);
                setTimeout(() => graph.d3AlphaTarget(0), 20);
            } else if (typeof graph.refresh === 'function') {
                graph.refresh();
            }
        }
    }

    let radialEnabled = false; 
    let ringsEnabled = false;  

    function toggleRadial() {
        radialEnabled = !radialEnabled;
        document.getElementById('btnRadial').innerText = `Radial: ${radialEnabled ? 'on' : 'off'}`;
        // reapply forces on current graph
        if (graph) {
            if (radialEnabled) {
                graph.d3Force('radial', d3.forceRadial(d => {
                    if (d.status === 'CENTER') return 0;
                    if (d.status === 'GREEN') return 150;
                    if (d.status === 'YELLOW') return 500;
                    return 800;
                }).strength(0.8));
            } else {
                graph.d3Force('radial', null);
            }
            if (typeof graph.d3AlphaTarget === 'function') {
                graph.d3AlphaTarget(0.1).alpha(0.3); // wake up
                setTimeout(() => graph.d3AlphaTarget(0), 400);
            }
        }
    }

    function toggleRings() {
        ringsEnabled = !ringsEnabled;
        document.getElementById('btnRings').innerText = `Rings: ${ringsEnabled ? 'on' : 'off'}`;
        if (typeof graph.tickFrame === 'function') graph.tickFrame();
    }

    function computeCommunityCenters(nodes, elem) {
        // Assign each community an angle and position on the ring (only communities present in view)
        const communities = Array.from(new Set(nodes.map(n => (n.community || 'collector').toLowerCase()))).sort();
        const cx = elem.clientWidth / 2;
        const cy = elem.clientHeight / 2;
        const baseRadius = Math.min(elem.clientWidth, elem.clientHeight) * 0.18;
        communityCenters = {};
        communities.forEach((c, i) => {
            const angle = (i / communities.length) * Math.PI * 2 - Math.PI / 2; // start at top
            communityCenters[c] = {
                x: Math.cos(angle) * (baseRadius + (i % 3) * 20) + cx,
                y: Math.sin(angle) * (baseRadius + (i % 3) * 20) + cy,
                angle
            };
        });
    }

    function applyCommunityForces(enable, elem) {
        if (!graph) return;
        if (enable) {
            // weak attraction to community centers so same-community nodes form visible sub-clusters
            graph.d3Force('communityX', d3.forceX(d => (communityCenters[(d.community||'collector').toLowerCase()] || communityCenters['collector']).x).strength(0.02));
            graph.d3Force('communityY', d3.forceY(d => (communityCenters[(d.community||'collector').toLowerCase()] || communityCenters['collector']).y).strength(0.02));
            document.getElementById('btnCluster').innerText = 'Cluster: on';
        } else {
            graph.d3Force('communityX', null);
            graph.d3Force('communityY', null);
            document.getElementById('btnCluster').innerText = 'Cluster: off';
        }
        clusterEnabled = enable;
        // nudge sim for a short burst to let clusters form visually (non-destructive)
        if (typeof graph.d3AlphaTarget === 'function') {
            graph.d3AlphaTarget(0.12);
            setTimeout(() => graph.d3AlphaTarget(0.001), 600);
        }
    }

    function toggleClusterLayout() {
        if (!graph) return;
        const elem = document.getElementById('graph-container');
        if (!clusterEnabled) computeCommunityCenters(graph.graphData().nodes, elem);
        applyCommunityForces(!clusterEnabled, elem);
    }

    async function drawGraph() { 
        const centerInput = document.getElementById('centerNode').value.trim();
        if(!centerInput) return alert("Please enter an address or ID");

        try {
            // Build query params from controls
            const tag = document.getElementById('filterTag').value.trim();
            const maxFirst = Number(document.getElementById('maxFirst').value) || 80;
            const params = new URLSearchParams();
            if (tag) params.set('tag', tag);
            params.set('max_first', String(maxFirst));

            const res = await fetch(`http://127.0.0.1:8000/graph/${centerInput}?${params.toString()}`);
            const rawData = await res.json();
            
            if (!res.ok) {
                throw new Error(rawData.detail || "API Error");
            }

            if (!rawData.nodes || rawData.nodes.length === 0) {
                throw new Error("No graph data found for this address.");
            }
            
            // Map status & roles to colors (The Signal System)
            const nodeIds = new Set(rawData.nodes.map(n => String(n.id)));
            
            // Community Palette
            const communityColors = {
                'photography': '#38bdf8', // light blue
                'glitch': '#f43f5e',      // rose/red
                '3d': '#8b5cf6',          // purple
                'illustration': '#fb923c',// orange
                'pfp': '#2dd4bf',         // teal
                'og_artist': '#ec4899',   // pink
                'artist': '#ec4899',      // pink
                'whale': '#facc15',       // yellow
                'og': '#818cf8',          // indigo
                'collector': '#94a3b8'    // slate
            };

            // fallback palette (for auto-detected communities like c0,c1...)
            const fallbackPalette = ['#60a5fa','#f472b6','#a78bfa','#fbbf24','#34d399','#f97316','#60a5fa'];
            function getCommunityColor(c) {
                if (!c) return communityColors['collector'];
                const key = String(c).toLowerCase();
                if (communityColors[key]) return communityColors[key];
                // hash to pick fallback
                let h = 0; for (let i=0;i<key.length;i++) h = (h<<5) - h + key.charCodeAt(i);
                return fallbackPalette[Math.abs(h) % fallbackPalette.length];
            }

            const nodes = rawData.nodes.map(n => {
                const comm = (n.community || 'collector').toLowerCase();
                const baseColor = getCommunityColor(comm);
                
                return {
                    ...n,
                    id: String(n.id),
                    baseColor: baseColor,
                    color: baseColor, // for default engine fallback
                    size: Math.sqrt(n.score || 1) * 0.8 + 3
                }
            });

            const showSecond = document.getElementById('showSecond').checked;
            const validLinks = rawData.edges
                .filter(e => nodeIds.has(String(e.from)) && nodeIds.has(String(e.to)))
                .filter(e => showSecond ? true : (e.hop !== 2))
                .map(e => ({
                    source: String(e.from),
                    target: String(e.to),
                    value: e.value,
                    hop: e.hop
                }));

            // Remove nodes that became isolated by client-side filters (keeps the center always)
            const linkedNodeIds = new Set(validLinks.flatMap(l => [l.source, l.target]));
            const filteredNodes = nodes.filter(n => linkedNodeIds.has(n.id) || n.group === 'center');

            const gData = {
                nodes: filteredNodes,
                links: validLinks
            };
            console.log("Sample Node Data:", filteredNodes[0]);

            const elem = document.getElementById('graph-container');
            if (graph) {
                // nudge previous simulation toward natural settle (do not pause)
                if (typeof graph.d3AlphaTarget === 'function') graph.d3AlphaTarget(0.001);
                elem.innerHTML = '';
            }

            graph = ForceGraph()(elem)
                .width(elem.clientWidth)
                .height(elem.clientHeight)
                .graphData(gData)
                .nodeId('id')
                .linkColor(l => {
                    // If hovering, hide non-neighbors
                    if (hoverNode && !neighborLinksLimited.has(l)) return 'rgba(0,0,0,0)';
                    // Color by hop distance
                    if (l.hop === 1) return 'rgba(56,189,248,0.45)';      // direct (blue)
                    if (l.hop === 2) return 'rgba(234,179,8,0.25)';      // discovery (gold)
                    return 'rgba(148,163,184,0.08)';                    // faint internal
                })
                .nodeColor(n => {
                    if (hoverNode && n.id !== hoverNode.id && !neighbors.has(n.id)) return 'rgba(31, 41, 55, 0.2)';
                    return n.baseColor;
                })
                .linkWidth(l => (neighborLinksLimited.has(l) ? 2.2 : (l.hop === 1 ? 1.2 : 0.6)))
                .linkDirectionalArrowLength(l => neighborLinksLimited.has(l) ? 4 : 0)
                .linkDirectionalArrowRelPos(1)
                .nodeVal(n => n.size) 
                .nodeLabel(null) 
                .onNodeHover(node => handleHover(node))
                .onNodeClick(node => {
                    const body = document.getElementById('modalBody');
                    body.innerHTML = `
                        <div><label>Name</label><span>${node.name || 'Anonymous'}</span><button class="btn-copy" onclick="copyText('${node.name || ''}')">Copy</button></div>
                        <div><label>Address</label><span style="font-size:0.8em">${node.address}</span><button class="btn-copy" onclick="copyText('${node.address}')">Copy</button></div>
                        <div><label>Primary Tag / Community</label><span style="text-transform: capitalize; font-weight: bold; color: ${node.baseColor}">${node.community}</span></div>
                        ${node.tags.length > 0 ? `<div><label>Known Tags</label><span style="color: #94a3b8">${node.tags.join(', ')}</span></div>` : ''}
                        <div><label>Global Rank</label><span># ${node.rank || 'N/A'} (Score: ${node.score.toFixed(2)})</span></div>
                        <div><label>Distance</label><span style="text-transform:capitalize">${node.group === 'center' ? 'Center' : node.group}</span></div>
                        <div><label>Subjective Match</label><span style="color: #22c55e">${node.subjective_score.toFixed(2)}% proximity</span></div>
                    `;
                    document.getElementById('modal').style.display = 'block';
                })
                .nodeCanvasObject((node, ctx, globalScale) => {
                    const label = node.name || node.address.substring(0, 6);
                    const fontSize = 14/globalScale;
                    ctx.font = `${fontSize}px monospace`;
                    
                    const r = node.size;
                    const isDimmed = hoverNode && node.id !== hoverNode.id && !(neighborsLimited.size ? neighborsLimited.has(node.id) : neighbors.has(node.id));
                    const isMain = node.score > 30 || node.status === 'CENTER' || (hoverNode && node.id === hoverNode.id);

                    // Node Circle
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, r, 0, 2 * Math.PI, false);
                    
                    const baseColor = node.baseColor || '#64748b';
                    ctx.fillStyle = isDimmed ? 'rgba(31, 41, 55, 0.2)' : baseColor;
                    
                    if (!isDimmed) {
                        ctx.shadowColor = baseColor;
                        ctx.shadowBlur = (node.status === 'GREEN' || isMain) ? 15/globalScale : 0;
                    }
                    
                    ctx.fill();
                    ctx.shadowBlur = 0; // reset
                    
                    // Trust Ring
                    if (!isDimmed) {
                        if (node.status === 'CENTER') {
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 3/globalScale;
                            ctx.stroke();
                        } else if (node.status === 'GREEN') {
                            ctx.strokeStyle = 'rgba(34, 197, 94, 0.8)';
                            ctx.lineWidth = 2/globalScale;
                            ctx.stroke();
                        }
                    }

                    // Text
                    if (isMain || globalScale > 2.5) { 
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillStyle = isDimmed ? 'rgba(248, 250, 252, 0.1)' : 'rgba(241, 245, 249, 0.9)';
                        
                        if (isMain) ctx.font = `bold ${fontSize}px monospace`;
                        ctx.fillText(label, node.x, node.y + r + fontSize);
                        
                        // Community Tag
                        if (!isDimmed && node.community && node.community !== 'artist' && globalScale > 3.5) {
                            ctx.font = `${fontSize * 0.7}px monospace`;
                            ctx.fillStyle = 'rgba(148, 163, 184, 0.8)';
                            ctx.fillText(node.community.toUpperCase(), node.x, node.y + r + fontSize * 2);
                        }
                    }

                    // Hover Tooltip (replacing native nodeLabel to ensure it updates during static mode)
                    if (hoverNode && node.id === hoverNode.id) {
                        const tip = `${node.name || node.address}\n${node.community}\nSubjective: ${node.subjective_score.toFixed(1)}%`;
                        const lines = tip.split('\n');
                        const tipFont = 12/globalScale;
                        ctx.font = `bold ${tipFont}px monospace`;
                        const padding = 8/globalScale;
                        const lineHeight = tipFont * 1.2;
                        const boxWidth = Math.max(...lines.map(l => ctx.measureText(l).width)) + padding * 2;
                        const boxHeight = lines.length * lineHeight + padding * 2;
                        
                        ctx.fillStyle = 'rgba(15, 23, 42, 0.95)';
                        ctx.strokeStyle = node.baseColor;
                        ctx.lineWidth = 1/globalScale;
                        ctx.fillRect(node.x + r + 5, node.y - boxHeight/2, boxWidth, boxHeight);
                        ctx.strokeRect(node.x + r + 5, node.y - boxHeight/2, boxWidth, boxHeight);
                        
                        ctx.fillStyle = '#f8fafc';
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'top';
                        lines.forEach((line, i) => {
                            ctx.fillText(line, node.x + r + 5 + padding, node.y - boxHeight/2 + padding + i * lineHeight);
                        });
                    }

                    // Neighbor labels (show linked node names on hover regardless of zoom)
                    if (hoverNode && (neighborsLimited.size ? neighborsLimited.has(node.id) : neighbors.has(node.id)) && node.id !== hoverNode.id) {
                        const neighborLabel = node.name || node.address.substring(0,6);
                        const nkFont = Math.max(10, fontSize * 0.9);
                        ctx.font = `bold ${nkFont}px monospace`;
                        const padding = 6/globalScale;
                        const textWidth = Math.min(220, ctx.measureText(neighborLabel).width + padding * 2);
                        const tx = node.x + r + 8;
                        const ty = node.y - r - nkFont;

                        // background
                        ctx.globalAlpha = 0.9;
                        ctx.fillStyle = 'rgba(6,10,20,0.85)';
                        ctx.fillRect(tx - padding, ty - nkFont, textWidth, nkFont + padding);
                        ctx.globalAlpha = 1;

                        // text
                        ctx.fillStyle = 'rgba(241,245,249,0.95)';
                        ctx.textAlign = 'left';
                        ctx.fillText(neighborLabel, tx, ty + nkFont * 0.15);
                    }
                });

            // Physics Tuning - Radial Reputation Layout
            graph.d3Force('charge').strength(-220); // Slightly stronger push
            graph.d3Force('link').distance(50).strength(0.05); // Very weak links to allow radial rings to form without torque
            
            // Remove standard center force - replace with radial
            graph.d3Force('center', null);
            
            const RADIUS_1 = 150;
            const RADIUS_2 = 500;
            const RADIUS_3 = 800;

            graph.d3Force('radial', d3.forceRadial(d => {
                if (d.status === 'CENTER') return 0;
                if (d.status === 'GREEN') return RADIUS_1;
                if (d.status === 'YELLOW') return RADIUS_2;
                return RADIUS_3;
            }, 0, 0).strength(0.8)); // Lower strength reduces "rotation friction"

            // ADDED: Anchor forces to prevent global rotation drift
            graph.d3Force('x', d3.forceX().strength(0.01));
            graph.d3Force('y', d3.forceY().strength(0.01));

            // Add background rings to the canvas
            graph.onRenderFramePre((ctx, scale) => {
                ctx.save();
                ctx.beginPath();
                ctx.setLineDash([5, 10]);
                ctx.strokeStyle = 'rgba(148, 163, 184, 0.1)';
                
                // Draw 3 rings
                ctx.arc(0, 0, RADIUS_1, 0, 2 * Math.PI);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.arc(0, 0, RADIUS_2, 0, 2 * Math.PI);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.arc(0, 0, RADIUS_3, 0, 2 * Math.PI);
                ctx.stroke();
                
                // Ring Labels
                ctx.font = `${20/scale}px monospace`;
                ctx.fillStyle = 'rgba(148, 163, 184, 0.3)';
                ctx.fillText("TRUSTED", RADIUS_1 + 10, 0);
                ctx.fillText("KNOWN", RADIUS_2 + 10, 0);
                ctx.fillText("DISCOVERY", RADIUS_3 + 10, 0);
                
                ctx.restore();
            });

            // Keep the spatial index fresh (throttled) so pointer detection remains accurate
            graph.onRenderFramePost(() => {
                // intentionally empty - quadtree manual hover removed to fix offset
            });

            // Add nodePointerAreaPaint to make hovering easier
            graph.nodePointerAreaPaint((node, color, ctx) => {
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(node.x, node.y, node.size + 10, 0, 2 * Math.PI, false);
                ctx.fill();
            });

            // Zoom to fit after a short delay to allow initial layout â€” let the sim naturally cool
            setTimeout(() => {
                graph.zoomToFit(600, 100);
            }, 800);
        } catch (err) {
            console.error('drawGraph error', err);
            try { alert(err.message || String(err)); } catch (__) { /* ignore in non-browser tests */ }
        }
    } // drawGraph

    // expose for debugging
    window.drawGraph = drawGraph;
    window.copyText = copyText;
    window.closeModal = closeModal;
    window.toggleRadial = toggleRadial;
    window.toggleRings = toggleRings;
    window.toggleClusterLayout = toggleClusterLayout;
    console.info('viz-force: drawGraph loaded');
</script>
</body>
</html>
