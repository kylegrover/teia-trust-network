<!DOCTYPE html>
<html>
<head>
    <title>Teia Trust Graph MVP2 (Force-Graph)</title>
    <script src="https://unpkg.com/d3"></script>
    <script src="https://unpkg.com/force-graph"></script>
    <style>
        body { background: #0f172a; color: #f8fafc; font-family: monospace; margin: 0; overflow: hidden; }
        #controls { height: 60px; padding: 10px 20px; background: #1e293b; border-bottom: 1px solid #334155; display: flex; gap: 10px; align-items: center; }
        #legend { position: absolute; bottom: 20px; left: 20px; background: rgba(15, 23, 42, 0.9); padding: 15px; border-radius: 8px; border: 1px solid #334155; z-index: 5; font-size: 0.8em; line-height: 1.6em; }
        #graph-container { width: 100vw; height: calc(100vh - 80px); background: #0f172a; position: relative; min-height: 400px; }
        input { background: #334155; border: 1px solid #475569; color: white; padding: 10px; min-width: 350px; border-radius: 4px; }
        button { background: #2563eb; color: white; border: none; padding: 10px 20px; cursor: pointer; border-radius: 4px; font-weight: bold;}
        button:hover { background: #1d4ed8; }
        .legend-item { display: flex; align-items: center; gap: 8px; }
        .dot { width: 10px; height: 10px; border-radius: 50%; }
        .community-photography { background: #38bdf8; }
        .community-glitch { background: #f43f5e; }
        .community-3d { background: #8b5cf6; }
        .community-illustration { background: #fb923c; }
        .community-pfp { background: #2dd4bf; }
        
        /* Modal Styles */
        #modal { display: none; position: fixed; z-index: 10; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); }
        .modal-content { background: #1e293b; margin: 15% auto; padding: 20px; border: 1px solid #334155; width: 400px; border-radius: 8px; position: relative; }
        .modal-header { font-size: 1.2em; font-weight: bold; margin-bottom: 15px; border-bottom: 1px solid #334155; padding-bottom: 10px; }
        .modal-body div { margin-bottom: 15px; }
        .modal-body label { color: #94a3b8; display: block; font-size: 0.8em; margin-bottom: 4px; }
        .close { position: absolute; right: 20px; top: 15px; cursor: pointer; color: #94a3b8; }
        .btn-copy { background: #475569; font-size: 0.7em; margin-left: 5px; padding: 4px 8px; color: white; border: none; border-radius: 3px; cursor: pointer; }
    </style>
</head>
<body>

<div id="controls">
    <label>Center:</label>
    <input type="text" id="centerNode" placeholder="tz... or id" value="">
    <button onclick="drawGraph()">Visualize Trust</button>
    <button id="btnToggleLock" onclick="toggleLockLayout()" title="Lock positions to stop motion but keep hover/zoom">Settle layout</button>
    <button id="btnTick" onclick="tickOnce()" title="Force a single render tick">Tick</button>
    <button id="btnCluster" onclick="toggleClusterLayout()" title="Toggle community clustering">Cluster: off</button>
</div>

<div id="graph-container"></div>

<div id="legend">
    <div class="legend-item"><div class="dot community-photography"></div> <span>Photography</span></div>
    <div class="legend-item"><div class="dot community-glitch"></div> <span>Glitch Art</span></div>
    <div class="legend-item"><div class="dot community-3d"></div> <span>3D / Generative</span></div>
    <div class="legend-item"><div class="dot community-illustration"></div> <span>Illustration</span></div>
    <div class="legend-item"><div class="dot community-pfp"></div> <span>PFP / Collectibles</span></div>
    <div style="margin-top:8px; color: #94a3b8; font-size: 0.9em; border-top: 1px solid #334155; padding-top: 8px;">
        <span style="color:#22c55e">ðŸŸ¢ Green Outer Ring:</span> Directly Trusted<br>
        <span style="color:#ffffff">â­• White Center:</span> High Reputation<br>
        <b>Hover node to focus paths</b>
    </div>
</div>

<div id="modal">
    <div class="modal-content">
        <span class="close" onclick="closeModal()">&times;</span>
        <div class="modal-header">Profile Info</div>
        <div class="modal-body" id="modalBody"></div>
    </div>
</div>

<script>
    let graph;
    let hoverNode = null;
    const neighbors = new Set();
    const neighborLinks = new Set();
    let simulationSettled = false; // true when layout has cooled but interactions remain active

    function closeModal() { document.getElementById('modal').style.display = 'none'; }
    function copyText(text) {
        navigator.clipboard.writeText(text).then(() => {
            const btn = event.target;
            const originalText = btn.innerText;
            btn.innerText = "Copied!";
            setTimeout(() => btn.innerText = originalText, 1000);
        });
    }

    // --- Layout control helpers ---
    let clusterEnabled = false;
    let communityCenters = {}; // computed per view
    const MAX_NEIGHBOR_LABELS = 40; // avoid extreme clutter

    function computeCommunityCenters(nodes, elem) {
        // Assign each community an angle and position on the ring (only communities present in view)
        const communities = Array.from(new Set(nodes.map(n => (n.community || 'collector').toLowerCase()))).sort();
        const cx = elem.clientWidth / 2;
        const cy = elem.clientHeight / 2;
        const baseRadius = Math.min(elem.clientWidth, elem.clientHeight) * 0.18;
        communityCenters = {};
        communities.forEach((c, i) => {
            const angle = (i / communities.length) * Math.PI * 2 - Math.PI / 2; // start at top
            communityCenters[c] = {
                x: Math.cos(angle) * (baseRadius + (i % 3) * 20) + cx,
                y: Math.sin(angle) * (baseRadius + (i % 3) * 20) + cy,
                angle
            };
        });
    }

    function applyCommunityForces(enable, elem) {
        if (!graph) return;
        if (enable) {
            // weak attraction to community centers so same-community nodes form visible sub-clusters
            graph.d3Force('communityX', d3.forceX(d => (communityCenters[(d.community||'collector').toLowerCase()] || communityCenters['collector']).x).strength(0.02));
            graph.d3Force('communityY', d3.forceY(d => (communityCenters[(d.community||'collector').toLowerCase()] || communityCenters['collector']).y).strength(0.02));
            document.getElementById('btnCluster').innerText = 'Cluster: on';
        } else {
            graph.d3Force('communityX', null);
            graph.d3Force('communityY', null);
            document.getElementById('btnCluster').innerText = 'Cluster: off';
        }
        clusterEnabled = enable;
        // nudge sim for a short burst to let clusters form visually
        if (typeof graph.d3AlphaTarget === 'function') {
            graph.d3AlphaTarget(0.12);
            setTimeout(() => graph.d3AlphaTarget(0), 600);
        }
    }

    function toggleClusterLayout() {
        if (!graph) return;
        const elem = document.getElementById('graph-container');
        if (!clusterEnabled) computeCommunityCenters(graph.graphData().nodes, elem);
        applyCommunityForces(!clusterEnabled, elem);
    }

    function lockLayout() {
        if (!graph || !graph.graphData) return;
        // Freeze visible node positions so the layout no longer drifts or rotates
        graph.graphData().nodes.forEach(n => { n.fx = n.x; n.fy = n.y; });
        // Disable user dragging to avoid torque-induced rotation
        if (typeof graph.enableNodeDrag === 'function') graph.enableNodeDrag(false);
        // Ensure simulation alpha is low but allow one-off frames for hover
        if (typeof graph.d3AlphaTarget === 'function') graph.d3AlphaTarget(0);
        simulationSettled = true;
        document.getElementById('btnToggleLock').innerText = 'Unlock layout';
    }

    function unlockLayout() {
        if (!graph || !graph.graphData) return;
        graph.graphData().nodes.forEach(n => { delete n.fx; delete n.fy; });
        if (typeof graph.enableNodeDrag === 'function') graph.enableNodeDrag(true);
        // nudge the sim so nodes can relax again
        if (typeof graph.d3AlphaTarget === 'function') graph.d3AlphaTarget(0.2);
        simulationSettled = false;
        document.getElementById('btnToggleLock').innerText = 'Settle layout';
    }

    function toggleLockLayout() {
        if (!graph) return;
        if (simulationSettled) unlockLayout(); else lockLayout();
    }

    function tickOnce() {
        if (!graph) return;
        if (typeof graph.tickFrame === 'function') return graph.tickFrame();
        // fallback: tiny alpha nudge
        if (typeof graph.d3AlphaTarget === 'function') {
            graph.d3AlphaTarget(0.01);
            setTimeout(() => graph.d3AlphaTarget(0), 40);
        }
    }

    async function drawGraph() { 
        const centerInput = document.getElementById('centerNode').value.trim();
        if(!centerInput) return alert("Please enter an address or ID");

        try {
            const res = await fetch(`http://127.0.0.1:8000/graph/${centerInput}`);
            const rawData = await res.json();
            
            if (!res.ok) {
                throw new Error(rawData.detail || "API Error");
            }

            if (!rawData.nodes || rawData.nodes.length === 0) {
                throw new Error("No graph data found for this address.");
            }
            
            // Map status & roles to colors (The Signal System)
            const nodeIds = new Set(rawData.nodes.map(n => String(n.id)));
            
            // Community Palette
            const communityColors = {
                'photography': '#38bdf8', // light blue
                'glitch': '#f43f5e',      // rose/red
                '3d': '#8b5cf6',          // purple
                'illustration': '#fb923c',// orange
                'pfp': '#2dd4bf',         // teal
                'og_artist': '#ec4899',   // pink
                'artist': '#ec4899',      // pink
                'whale': '#facc15',       // yellow
                'og': '#818cf8',          // indigo
                'collector': '#94a3b8'    // slate
            };

            const nodes = rawData.nodes.map(n => {
                const comm = (n.community || 'collector').toLowerCase();
                const baseColor = communityColors[comm] || communityColors['collector'];
                
                return {
                    ...n,
                    id: String(n.id),
                    baseColor: baseColor,
                    color: baseColor, // for default engine fallback
                    size: Math.sqrt(n.score || 1) * 0.8 + 3
                }
            });

            const validLinks = rawData.edges
                .filter(e => nodeIds.has(String(e.from)) && nodeIds.has(String(e.to)))
                .map(e => ({
                    source: String(e.from),
                    target: String(e.to),
                    value: e.value
                }));

            const gData = {
                nodes: nodes,
                links: validLinks
            };
            console.log("Sample Node Data:", nodes[0]);

            const elem = document.getElementById('graph-container');
            if (graph) {
                // gently cool the previous simulation but keep interaction handlers active
                if (typeof graph.d3AlphaTarget === 'function') graph.d3AlphaTarget(0);
                simulationSettled = true;
                elem.innerHTML = '';
            }

            graph = ForceGraph()(elem)
                .width(elem.clientWidth)
                .height(elem.clientHeight)
                .graphData(gData)
                .nodeId('id')
                .nodeVal(n => n.size) 
                .nodeLabel(n => `
                    <b>${n.name || n.address}</b><br>
                    Community: ${n.community}<br>
                    Global Score: ${n.score?.toFixed(2)}<br>
                    Match: ${n.subjective_score?.toFixed(2)}%
                `)
                .nodeColor(n => {
                    if (hoverNode && n.id !== hoverNode.id && !neighbors.has(n.id)) return 'rgba(31, 41, 55, 0.2)';
                    return n.baseColor;
                })
                .linkWidth(l => (neighborLinks.has(l) ? 2 : 1))
                .linkColor(l => {
                    if (hoverNode && !neighborLinks.has(l)) return 'rgba(0,0,0,0)';
                    if (l.source.id === rawData.nodes.find(n => n.group === 'center')?.id) return 'rgba(56, 189, 248, 0.4)';
                    return 'rgba(148, 163, 184, 0.1)';
                })
                .linkDirectionalArrowLength(l => neighborLinks.has(l) ? 4 : 0)
                .linkDirectionalArrowRelPos(1)
                .onNodeHover(node => {
                    neighbors.clear();
                    neighborLinks.clear();
                    if (node) {
                        hoverNode = node;
                        graph.graphData().links.forEach(link => {
                            const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                            const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                            
                            if (sourceId === node.id || targetId === node.id) {
                                neighborLinks.add(link);
                                neighbors.add(sourceId);
                                neighbors.add(targetId);
                            }
                        });
                    } else {
                        hoverNode = null;
                    }
                    elem.style.cursor = node ? 'pointer' : null;
                    // Force a single render frame so hover highlights appear even after layout cooled.
                    if (typeof graph.tickFrame === 'function') {
                        graph.tickFrame();
                    } else if (typeof graph.d3AlphaTarget === 'function') {
                        // nudge the simulation so it produces one frame without fully resuming
                        graph.d3AlphaTarget(0.01);
                        setTimeout(() => graph.d3AlphaTarget(0), 60);
                    }
                })
                .onNodeClick(node => {
                    const body = document.getElementById('modalBody');
                    body.innerHTML = `
                        <div><label>Name</label><span>${node.name || 'Anonymous'}</span><button class="btn-copy" onclick="copyText('${node.name || ''}')">Copy</button></div>
                        <div><label>Address</label><span style="font-size:0.8em">${node.address}</span><button class="btn-copy" onclick="copyText('${node.address}')">Copy</button></div>
                        <div><label>Primary Tag / Community</label><span style="text-transform: capitalize; font-weight: bold; color: ${node.baseColor}">${node.community}</span></div>
                        ${node.tags.length > 0 ? `<div><label>Known Tags</label><span style="color: #94a3b8">${node.tags.join(', ')}</span></div>` : ''}
                        <div><label>Global Rank</label><span># ${node.rank || 'N/A'} (Score: ${node.score.toFixed(2)})</span></div>
                        <div><label>Subjective Match</label><span style="color: #22c55e">${node.subjective_score.toFixed(2)}% proximity</span></div>
                    `;
                    document.getElementById('modal').style.display = 'block';
                })
                .nodeCanvasObject((node, ctx, globalScale) => {
                    const label = node.name || node.address.substring(0, 6);
                    const fontSize = 14/globalScale;
                    ctx.font = `${fontSize}px monospace`;
                    
                    const r = node.size;
                    const isDimmed = hoverNode && node.id !== hoverNode.id && !neighbors.has(node.id);
                    const isMain = node.score > 30 || node.status === 'CENTER' || (hoverNode && node.id === hoverNode.id);
                    
                    // Node Circle
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, r, 0, 2 * Math.PI, false);
                    
                    const baseColor = node.baseColor || '#64748b';
                    ctx.fillStyle = isDimmed ? 'rgba(31, 41, 55, 0.2)' : baseColor;
                    
                    if (!isDimmed) {
                        ctx.shadowColor = baseColor;
                        ctx.shadowBlur = (node.status === 'GREEN' || isMain) ? 15/globalScale : 0;
                    }
                    
                    ctx.fill();
                    ctx.shadowBlur = 0; // reset
                    
                    // Trust Ring
                    if (!isDimmed) {
                        if (node.status === 'CENTER') {
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 3/globalScale;
                            ctx.stroke();
                        } else if (node.status === 'GREEN') {
                            ctx.strokeStyle = 'rgba(34, 197, 94, 0.8)';
                            ctx.lineWidth = 2/globalScale;
                            ctx.stroke();
                        }
                    }

                    // Text
                    if (isMain || globalScale > 2.5) { 
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillStyle = isDimmed ? 'rgba(248, 250, 252, 0.1)' : 'rgba(241, 245, 249, 0.9)';
                        
                        if (isMain) ctx.font = `bold ${fontSize}px monospace`;
                        ctx.fillText(label, node.x, node.y + r + fontSize);
                        
                        // Community Tag
                        if (!isDimmed && node.community && node.community !== 'artist' && globalScale > 3.5) {
                            ctx.font = `${fontSize * 0.7}px monospace`;
                            ctx.fillStyle = 'rgba(148, 163, 184, 0.8)';
                            ctx.fillText(node.community.toUpperCase(), node.x, node.y + r + fontSize * 2);
                        }
                    }

                    // Neighbor labels (show linked node names on hover regardless of zoom)
                    if (hoverNode && neighbors.has(node.id)) {
                        const neighborLabel = node.name || node.address.substring(0,6);
                        const nkFont = Math.max(10, fontSize * 0.9);
                        ctx.font = `bold ${nkFont}px monospace`;
                        const padding = 6/globalScale;
                        const textWidth = Math.min(220, ctx.measureText(neighborLabel).width + padding * 2);
                        const tx = node.x + r + 8;
                        const ty = node.y - r - nkFont;

                        // background
                        ctx.globalAlpha = 0.9;
                        ctx.fillStyle = 'rgba(6,10,20,0.85)';
                        ctx.fillRect(tx - padding, ty - nkFont, textWidth, nkFont + padding);
                        ctx.globalAlpha = 1;

                        // text
                        ctx.fillStyle = 'rgba(241,245,249,0.95)';
                        ctx.textAlign = 'left';
                        ctx.fillText(neighborLabel, tx, ty + nkFont * 0.15);
                    }
                });

            // Physics Tuning - Radial Reputation Layout
            graph.d3Force('charge').strength(-220); // Slightly stronger push
            graph.d3Force('link').distance(50).strength(0.05); // Very weak links to allow radial rings to form without torque
            
            // Remove standard center force - replace with radial
            graph.d3Force('center', null);
            
            const RADIUS_1 = 150;
            const RADIUS_2 = 500;
            const RADIUS_3 = 800;

            graph.d3Force('radial', d3.forceRadial(d => {
                if (d.status === 'CENTER') return 0;
                if (d.status === 'GREEN') return RADIUS_1;
                if (d.status === 'YELLOW') return RADIUS_2;
                return RADIUS_3;
            }, 0, 0).strength(0.8)); // Lower strength reduces "rotation friction"

            // ADDED: Anchor forces to prevent global rotation drift
            graph.d3Force('x', d3.forceX().strength(0.01));
            graph.d3Force('y', d3.forceY().strength(0.01));

            // Add background rings to the canvas
            graph.onRenderFramePre((ctx, scale) => {
                ctx.save();
                ctx.beginPath();
                ctx.setLineDash([5, 10]);
                ctx.strokeStyle = 'rgba(148, 163, 184, 0.1)';
                
                // Draw 3 rings
                ctx.arc(0, 0, RADIUS_1, 0, 2 * Math.PI);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.arc(0, 0, RADIUS_2, 0, 2 * Math.PI);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.arc(0, 0, RADIUS_3, 0, 2 * Math.PI);
                ctx.stroke();
                
                // Ring Labels
                ctx.font = `${20/scale}px monospace`;
                ctx.fillStyle = 'rgba(148, 163, 184, 0.3)';
                ctx.fillText("TRUSTED", RADIUS_1 + 10, 0);
                ctx.fillText("KNOWN", RADIUS_2 + 10, 0);
                ctx.fillText("DISCOVERY", RADIUS_3 + 10, 0);
                
                ctx.restore();
            });

            // Collision to prevent overlap in dense rings
            graph.d3Force('collide', d3.forceCollide(n => n.size + 6));

            // Zoom to fit after a short delay to allow initial layout â€” then pause for a static view
            setTimeout(() => {
                graph.zoomToFit(600, 100);
                // Lock positions after the camera settles so we stop motion but keep pointer events
                lockLayout();
            }, 800);

        } catch (e) {
            console.error(e);
            alert("Error: " + e.message);
        }
    }

    // expose for debugging
    console.info('viz-force: drawGraph loaded');
</script>
</body>
</html>
